学習日記

2025/11/22
○ITパスポート試験 740点/1000点 合格
・ストラテジ……555点
・マネジメント……855点
・テクノロジ……805点

○基本情報技術者試験 合格
・科目A……680点
・科目B……885点


2025/11/05
paizaのB問題解けた。
2次元配列をどう扱うかがわかった。
python 3

2025/11/07
paizaでBランクになった。
リスト内包表記について、かなり慣れた。
ごく基本的なことではあるが、繰り返し練習する中で、息をするように（手癖のように）書けるコードも出てきた

2025/11/09
N,M,K=[int(x) for x in input().split()]
a=[int(x) for x in input().split()]
# b=[int(x) for x in input().split()]

# .appendは、元の配列を直接変更する。返り値自体はNone
# del文の文法はappendとは違う。del 配列[消したい要素番号]　元の配列自体を変更する
# .insert(場所,要素) で指定位置に挿入
a.insert(M-1,K)
for i in a:
    print(i)

リストの操作について、基本的なことの反復練習をした。paizaを順に進めている


(x,y)がN個与えられ、A番目の点とB番目の点の距離を求める問題
x座標が入る箱と、y座標が入る箱を用意すればいい。インデックス番号をA-1とかにしたら指定できる
N,A,B=[int(x) for x in input().split()]

X=[]
Y=[]

for i in range(N):
    x_i,y_i=[int(x) for x in input().split()] # 行ごとに座標を受け取る
    X.append(x_i) # 箱詰めする
    Y.append(y_i)　# 箱詰めする

d= abs(X[A-1]-X[B-1])+abs(Y[A-1]-Y[B-1])
print(d)

二重ループの仕組みを理解して、適切に二次元配列を受け取って表示することができた
# N=int(input())
N,K=[int(x) for x in input().split()]

for i in range(N):
    a=list(map(int,input().split()))
    for j in range(K):
        if j<K-1:
            print(a[j],end=" ")
        else:
            print(a[j])

階段の出力　意外と苦戦した。紙に書いて整理したらわかった
Nは単に回数ではなく、１からNまで動いて欲しかったので、range(N)ではいかん
N=int(input())
for k in range(1,N+1):
    for i in range(1,k+1):# 1 からkまでの数字を横に並べる
        if i<k:
            print(i,end=" ")
        else:
            print(i)

N以下の素数判定プログラム。自力で全部考えて実装できた嬉しい
よくあるのはN以下の数で片っ端から割っていくやつやけど、偶数で割ってみたりしているのが無駄やなぁと思っていた。
そこで、素数を入れる配列primeを作り、判定対象の整数をこの配列prime内の数でのみ割ってみることにした。そうすれば計算回数が大幅に減る。
また、素数リストで割った時の余りが全て０以外なら素数であり、言い換えれば１つでも余りが０になれば素数でない。
これは、「余りを全て掛け合わせて０になる」かどうかを調べれば良い。１つでも０があれば積は０であり、素数でない。
このようにして新たな素数を発見し、素数を入れる配列primeに追加していく。
課題：別に19が素数であるかを調べるのに17で割る必要はない。primeの要素全てで割っていくのではなく、途中の√N までの段階で止めればより効率化される。

N=int(input())
prime=[2]
for k in range(3,N+1):
    s=1
    for m in prime:
        s=s*(k%m)
    if s!=0:
        prime.append(k)
print(len(prime))


名前、点数　の形で入力される場合
下のように、２次元配列として受け取り、forの中ではそれぞれの行に対して各要素をname,scoreという形で受け取るといい
そうすることで、int(score)の処理がわかりやすいし、コード全体としても直感的でスッキリする
n=int(input())

results=[[x for x in input().split()] for _ in range(n)]

k,l=[int(x) for x in input().split()]

for name,score in results:
    if k<=int(score)<=l:
        print(name)

動的配列というものが突然出てきた。かなり苦戦した。
クエリによって入力の文字数が異なるので、split()を正しく適用できているかとかが大事だったっぽい

N,Q=[int(x) for x in input().split()]
an=[int(x) for x in input().split()]

query=[]
for i in range(Q):
    query.append(input())
   
for q in query:
    if q[0] == "2":
        print(*an)
    elif q[0] =="1":
        del an[-1]
    else:
        qw=q.split()
        an.append(int(qw[1]))

2025/11/10

今までは主にリストを使ってきた。辞書にはまだ慣れない
N,M=[int(x) for x in input().split()]
# a=[[x for x in input().split()] for _ in range(M)]
b={}
for i in range(N):
    # a.append(x for x in input().split()) ←これはダメ。チャッピーによると、これだと「リスト内包表記のオブジェクト」を入れてるだけで、実際のリストの中身が追加されてない。

    key,value=input().split()
    b[key]=value

for i in range (M):
    key=input()
    if key in b: ←if の条件文でinput()=b と書いていたが、そうすると次に出てくるinput()が違うものになってしまう。何回か同じ中身のinputを使いたいので、変数keyに代入しておく
        print(b[key])
    else:
        print(-1)

[::-1]で反転って変わった文法やと思ってたけど、[start:stop:step]の一部省略なんやな

paizaのB問題解いた。
N,K=[int(x) for x in input().split()]
prices=[[int(x) for x in input().split()] for _ in range(N)]

trans_prices=[[0]*N for _ in range(K)]
for i in range(N):
    for j in range(K):
        trans_prices[j][i]=prices[i][j]

mi=[]
for i in range(K):
    mi.append(min(trans_prices[i]))
# print(mi)

# mi リストのi番目が、pricesリストのどこにあるかを探す
# mi[0] が、prices[0][0] と一致するので、0を返す。これが店番号を控えるための鍵
# 二重ループを作る。mi[i]に対して、prices[j][i]が一致すればjを返す。
# mi[1] が、prices[2][1] と一致するので、2を返す。
# mi[2] が、prices[2][2] と一致するので、２を返す。
# 返ってきた値たちで集合を作り、その要素すうをプリントする

ans=set()
for i in range(K):
    for j in range(N):
        if mi[i]==prices[j][i]:
            ans.add(j)
print(len(ans))

自分なりにコメントで考え整理しながらやると、見通しよく進められた
    
2025/11/11
計算式を文字列で送り込んでくる問題に悪戦苦闘
S=input()
li=[S[i] for i in range(len(S))]
# print(li)
N=len(S)
# 作戦：liのi番目が+か-になったら、それまでの文字列を数値変換して演算

# 最初の項だけは普通に取り出す
for i in range(N):
    if li[i]=="+" or li[i]=="-":
        ans=int(li[:i])
        del li[:i]
        break
# n_1 は最初に演算子がきた配列番号

for i in range(n_1,N):
    if li[0] =="+":
        for j in range(1,len(li)):
            # 次の演算子を探す
            if li[j]=="+" or li[j]=="-":
                num=int(li[1:j])
                ans+=num
                del li[1:j]
                if li==[]:
                    break

    elif li[0] =="-":
        for j in range(1,len(li)):
            if li[j]=="+" or li[j]=="-":
                num=int(li[1:j])
                ans-=num
                del li[1:j]
                if li == []:
                    break        
print(ans)

自分でここまで書いたけどエラー出る。int(["1","5"])みたいなのを15に直してほしい感覚だけど、リストに入れてもあかんのやな
で、チャッピーに助言得て次のようにかけた。これは成功。

S=input()
# １文字区切りのリストにする
li=[x for x in S]
# print(li)

# １文字ずつ、演算子か数字かを判別。
# 数字なら一文字ずつ文字列として連結していく
# 演算子なら、そこまで連結してきた文字と演算する
# 演算したら、そこまでの文字列をリセットする
# 最初と最後だけは特別に処理する

enzanshi="+"
numset=""
ans=0

for mozi in li:
    if mozi in "+-":
        if enzanshi == "+":
            ans+=int(numset)
        elif enzanshi == "-":
            ans-=int(numset)
        numset=""
        enzanshi=mozi
    else:
        numset+=mozi
        
if enzanshi == "+":
    ans+=int(numset)
elif enzanshi == "-":
    ans-=int(numset)
    
print(ans)

辞書、ほんと慣れないけどこれが基本やから抑えとこう↓
n=int(input())
a={} # からの辞書を作成
for i in range(n):
    key,value = input().split() # この行は[key,value]としても問題ない
    a[key]=value # 辞書に要素を追加するにはこうやる！！

S=input()
print(a[S])


辞書のキーで並び替えるとか、値だけ抜き出すとか、意外と愚直にやるのが模範解答らしい
n=int(input())

dmg={}

for i in range(n):
    s=input()
    dmg[s]=0

m=int(input())

for i in range(m):
    k,v=input().split()
    v=int(v)
    dmg[k]+=v

# keys()でキーを取り出し、list()でリストにして、.sort()で並び替える
names=list(dmg.keys())

for name in sorted(names):
    print(dmg[name])

辞書の問題。初見で「はー無理やん」って思ったけどコメント活用して考え整理したらなんかいけた。超気持ちいい
# p,q,rはA,B,Cの人数
p,q,r=[int(x) for x in input().split()]

A_to_B = {}
B_to_C = {}

for i in range(p):
    k,v=input().split()
    k=int(k)
    v=int(v)
    A_to_B[k] = v

for i in range(q):
    k,v=input().split()
    k=int(k)
    v=int(v)
    B_to_C[k] = v

# A_to_B[i]が示す値は、Bグループのキーになる。これをBkとすると、
# B_to_C[Bk-1]が示す値が、Cグループの担当者。それ(ans)を出力する。
# iをi=1からi=pまで動かす

for i in range(1,p+1):
    Bk=A_to_B[i]
    ans=B_to_C[Bk]
    print(i,ans)

2025/11/13
paizaのB問題。１時間かかったけどなんとか解けた。
２次元配列以上になると、結局紙に書いてループの構造を把握するのがわかりやすい。

H,W,N = [int(x) for x in input().split()]

stamp = []

# 入力をH回読み込んで初めて１つのスタンプ
# １つのスタンプは、H行１列の配列
for j in range(N):
    one_stamp = []
    for i in range(H):
        one_stamp.append(input())
    stamp.append(one_stamp)

# print(stamp)

R,C = [int(x) for x in input().split()]

plan = []
for i in range(R):
    plan.append(list(map(int,input().split())))
# print(plan)

# まず左上。plan[0,0] = 1 であり、1のスタンプはstamp[1-1]にある。
# stamp[1-1]の0行め、すなわちstamp[0][0]を出力 abc
# 後ろに文字を続けたい。end=""で終わる
# 次にその右。plan[0,1] = 2 であり、2のスタンプはstamp[2-1]にある。
# stamp[2-1]の0行め、すなわちprint(stamp[1][0],end="") を書く。
# planの右端に達したら、つまりplanをc回繰り返したら、
# 改行のためにprint()
# ここで、各スタンプの「0行め」を指定した理由について、
# 各スタンプの縦の長さHに依存する。
# n を0からHまで動かして、「plan」１行ぶんの処理を回す。

# planはR行C列。plan[i][j] としたとき、まずjを0からCまで動かす
# i、つまりRの方は最後の最後にループさせる。ので一旦放置
# スタンプの指定：0~N-1の番号(plan[i][j] -1 に一致)。さらに何行目かも絞る
for i in range(R):
    for h in range(H):
        for j in range(C):
            print(stamp[plan[i][j]-1][h],end="")
        print()

2025/11/15
今日は趣向を変えて、統計学の勉強をした。
統計検定２級相当。分散分析の途中式がかなり複雑で不安になったが、問題解いてみたら腑に落ちた。
いろんな分布があるけど、実際どれもやっていることはそこまで大きくは変わらないように思う。
既知の情報を使って調べたいことを調べられそうな形に変形していったら、その統計量は実はこの分布に従うことが知られていて、
という知識があればあとはどうとでもなるような感覚。

2025/11/16
https://www.youtube.com/watch?v=fAJ_BjLd3Ro
これを参考に、Pythonでゲームを作った。ほとんど見よう見まねだが、ところどころ自己流の改良を施した。
このゲームはかなり拡張しがいがあると思うので、今後も暇を見てはいじっていきたい。
クラスを導入してコードを整理するところがまず最初の課題になりそう。
そのあとは好きなように弾の種類（貫通、拡散、巨大など）を増やしたり、敵の動きを数学的に面白くしたり、
効果音とかも色々導入して楽しめるようにしたい。
あとはハイスコアを記録できたら熱い

2025/11/27
基本情報技術者とITパスポートを受けるなどしていて少し間があいた
久しぶりにpaizaで特訓。辞書のソートが難しかったけど、うまくやるとすごくシンプルに書けるとわかった。
でもまだ理屈の理解が追いついていないので、辞書に関してはもっと慣れていかないと
複数条件でのソートだが、下のように１行でかくのがいい
身長、月、名前の順でソートしていくと、境界値が与えられたとき変なことになる（？）

stu.sort(key=lambda x: (x["height"], -x["month"], x["name"]))
for s in stu:
    print(s["name"])

2025/11/28
pandasについて基本的なことを学んだ
